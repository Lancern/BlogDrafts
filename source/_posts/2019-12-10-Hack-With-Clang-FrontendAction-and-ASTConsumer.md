---
title: "Hack with Clang: FrontendAction and ASTConsumer"
date: 2019-12-10 16:57:38
categories: Clang
tags:
- Clang
- LLVM
---

In this post, I want to share with you my recent study on Clang's internal design, particularly about `FrontendAction`s and `ASTConsumer`s, which are the fundamental building blocks of the Clang frontend. I'm going to dig deep into the implementation decisions around `FrontendAction` and `ASTConsumer`, and illustrate some problems not mentioned in the Clang's documentation. More precisely, I want to illustrate the following topics:

1. How does Clang architects in a whole?
2. What is `FrontendAction` and how does it work?
3. What is `ASTConsumer` and how does it work?

Throughout the discussion in this post, I'd like to talk about some unlisted problems about `FrontendAction` and `ASTConsumer`.

Before start, I'm assuming that you already have some background knowledge about LLVM and Clang, but not much.

This post uses Clang version 7.0.

# The Big Picture

Clang is a C/C++ compiler built on top of LLVM. More precisely, Clang is the *frontend* of C/C++ compiler. It takes some source program written in C/C++ programming language, and produces LLVM bitcode modules that can be further processed by the LLVM toolchain. LLVM bitcode is some sort of intermediate representation of a program used throughout the LLVM ecosystem, just like the bytecode in Java virtual machine and the IL in Common Language Runtime.

To convert source programs into LLVM bitcode modules, Clang has to perform the following steps, which should be familiar to you if you have experiences coping with compilers:

1. Lexical Analysis;
2. Syntax Analysis;
3. Semantic Analysis;
4. Source-Level Optimizations;
5. Code Emitting.

Details about what each phase does is far beyond the scope of this post. What I want to claim is that Clang is complex: many modules dealing with different parts of the job, not to mention Clang is supposed to compile the most complex programming language in the world (that's you, C++). To properly construct such a massive and complex software project, Clang heavily applies modularization approaches to its internal designs, which makes it highly scalable and hackable.

# The Pipeline

By doing some program trace job, I made the following figure to illustrate the overall pipeline of Clang:

![Clang Pipeline](/images/clang-pipeline.svg)

After Clang is launched, it initializes itself, checking command line arguments passed to it. Normally, when we launch Clang through the `clang` command, we are just launching a so called "driver" program, which is just a thin wrapper around the real clang program (`cc1`). The driver program makes certain conversions between various command line options so Clang can deal with the command line options originally designed for `gcc`.

When `cc1` is invoked, it creates a fresh `CompilerInstance` object, which is designed for maintaining compiler wide data throughout the compilation process, such as deserialized command line options, the symbol table generated by the lexer, the AST context information, the diagnostics engine, etc. More importantly, `CompilerInstance` objects maintain the additional plugins that are loaded from shared libraries and the main `FrontendAction` instance, which is the key to extend the Clang compiler infrastructure, and we will discuss them later in this post.

After that, `cc1` creates the main `FrontendAction` instance, with respect to the corresponding command line options, and execute it in the context of the `CompilerInstance` object. `FrontendAction` is really the very core of Clang since it contains all the core logic Clang executes as a compiler. `FrontendAction` is an abstract class with a bunch of built-in implementors. Some of the implementors are listed below:

* EmitAssemblyAction
* EmitBCAction
* EmitLLVMAction
* ASTDumpAction
* ...

Each action is triggered by different command line options passed to clang. For example, `EmitBCAction` contains all the logic that Clang has to execute in order to compile the source program into LLVM bitcode modules. If we launch clang with command line `clang -c --emit-llvm`, then `EmitBCAction` will be selected and created as the main `FrontendAction` of the compiler instance.

# The FrontendAction class

The very heart of Clang is an abstract class called `FrontendAction`, declared in `clang/include/clang/Frontend/FrontendAction.h` and implemented in `clang/lib/Frontend/FrontendAction.cpp`. Implementors of `FrontendAction` have to override the following 2 protected abstract methods:

* `CreateASTConsumer` and
* `ExecuteAction`.

`CreateASTConsumer` is a factory function that creates an `ASTConsumer` instance. `ASTConsumer` is the building block of Clang backend and Clang plugin system, i.e. the portion of Clang that emits target code (LLVM bitcode, assembly code, etc.) and handles plugins. As name suggests, `ASTConsumer` takes some part of the AST, and does some specific actions. We will discuss `ASTConsumer` later.

`ExecuteAction` is the "entry point" of `FrontendAction`s that contains all the logic that a specific `FrontendAction` needs to execute. For example, `EmitBCAction` overwrites this function to:

1. Parse source code into AST;
2. Call an specific implementation of `ASTConsumer` named `CodeGenerator` that consumes the AST and produces target code.

Clang implements many sub-classes of `FrontendAction`, each providing specific behavior provided by Clang. For a full list of implementors available, refer to Clang's doxygen documentation. Among all implementors, the most important implementors are those deriving from `ASTFrontendAction`. These implementors do their job based on the AST, leveraging `ASTConsumer`s to execute any actions that consumes the AST.

It should be noticed that the `PluginASTAction` class, deriving from `ASTFrontendAction`, is the entry point for Clang plugins. This class provides a default `ExecuteAction` method which ought to be inherited without modification by Clang plugins. Clang plugins should override the `CreateASTConsumer` method to create custom AST consumers for the plugin. We will discuss Clang plugins later.

Up until now, the pipeline of Clang can be illustrated by the following (psudo)code pieces:

```c++
int main(int argc, char* argv[]) {
    Initialize();   // Initialize Clang. This step includes analyzing the command line arguments.

    CompilerInstance* CI = new CompilerInstance();

    FrontendAction* mainAction;
    if (ActionToTake == EmitLLVM) {
        mainAction = new EmitLLVMAction();
    } else if (ActionToTake == EmitBC) {
        mainAction = new EmitBCAction();
    } else {
        // Other circumstances are ignored here for clarity.
    }

    return CI->ExecuteAction(mainAction);
}
```

# The ASTConsumer class And the Clang Backend

The Clang backend is the portion of Clang that is responsible for emitting target code (e.g. LLVM bitcode), given the AST generated by the parser. The building blocks of the Clang backend is the `ASTConsumer` class, which takes AST as input and produces some form of output, depending on the concrete implementor. For example, `CodeGenerator` derives from `ASTConsumer`, and it invokes code in the `CodeGen` module of Clang which is responsible for emitting target code from AST nodes.

Instances of `ASTConsumer` are created by `FrontendAction`s, as illustrated before. One `FrontendAction` can only creates one `ASTConsumer` corresponding to it. However, it should be noticed that, although only one `FrontendAction` object can be the "main" action, there could be multiple instances of `ASTConsumer` consuming the AST. For example, when we load some plugins into Clang, there might be multiple `ASTConsumer`s consuming the AST: some of the consumers are loaded from the plugins, and one of the consumers is loaded from the main `FrontendAction`, which could be `EmitBCAction`, for instance.

`ASTConsumer` defines some virtual methods that can be freely overridden by the implementors. Here are some of them:

* HandleTopLevelDecl
* HandleInlineFunctionDecl
* HandleInterestingDecl
* HandleTranslationUnit
* ...

The responsibility of each function listed above is trivial. For example, `HandleTranslationUnit` function receives a reference to the `ASTContext` class, which represents the AST of the whole translation unit. Implementors can override this function if they need to do some tasks based on the whole translation unit.

## Invocation of ASTConsumer by Clang

`ASTConsumer`s consume AST, so the AST needs to be generated first for `ASTConsumer`s to execute. In Clang, AST is generated after the semantic analyzation phase, and is generated by the semantic analyzer. The main logic of the semantic analyzer of Clang resides in the `Sema` class.

It should be noticed that Clang does **NOT** execute `ASTConsumer`s only after the AST has been **FULLY** generated, like some kind of batch processing. The `ASTConsumer`s are executed interactively with the parsing module: immeidiately after the parser has generated some AST nodes, the corresponding `HandleXXX` functions in the `ASTConsumer`s are called on these AST nodes. Finally, after the parser has completed parsing the whole translation unit, the `HandleTranslationUnit` function is called on these `ASTConsumer`s. More precisely, the parser and the `ASTConsumer`s are driven by a function called `ParseAST`, defined at `clang/lib/Parse/ParseAST.cpp:114`. This function's behavior can be illustrated by the following figure:

![Invocation of `ASTConsumers`](/images/invocation-of-ast-consumers.svg)

We said that multiple `ASTConsumer`s could be loaded into Clang simutaneously. So Clang needs to figure out an order between these `ASTConsumer`s in which these consumers can be executed. We also said that among these `ASTConsumers`, only one of them is created from the main frontend action, and the rest of them are loaded from Clang plugins. Clang solves this problem by defining a method called `getActionType` in the `PluginASTAction` class, which is the abstract base class of all Clang plugins. This function returns an enum `PluginASTAction::ActionType` which can be the following values:

* Cmdline
* ReplaceAction
* AddBeforeMainAction
* AddAfterMainAction

The first two values (`Cmdline` and `ReplaceAction`) is not related to the order problem, so we ignore them here. The `AddBeforeMainAction` and `AddAfterMainAction` variant is the key to solve this problem: if a Clang plugin overrides the `getActionType` function and returns `AddBeforeMainAction`, then the `ASTConsumer` created by this plugin will be executed before the `ASTConsumer` created by the main frontend action; similarly, if a Clang plugin returns `AddAfterMainAction`, then the `ASTConsumer` created by this plugin will be executed after the `ASTConsumer` created by the main frontend action. What's more, the relative execution order between the `ASTConsumer`s created by plugins are determined by the order the plugins are listed in the command line arguments passed to Clang.

## Ability of ASTConsumer

So far we have discussed how `ASTConsumer`s are created and organized in Clang, but we does not mention what exactly is the responsibility of an `ASTConsumer`. As the name suggests, `ASTConsumer`s "consume" AST: they should not modify the AST, should not generating new nodes and mount them onto the AST, should not deleting nodes from the AST. For instance, the backend of Clang is implemented through an `ASTConsumer`, which is the `CodeGenerator` class, since code generation do not require any modification to the AST and only "consumes" the AST. Actually, `CodeGenerator` is just a facade of the `CodeGen` module of Clang in the shape of an `ASTConsumer`. When the `HandleTopLevelDecl` function of `CodeGenerator` is called, `CodeGenerator` invokes corresponding functions in the `CodeGen` module to do the actual code emitting work. Another example of `ASTConsumer` is the `PrintFunctionNames` plugin, which is an official example of the usage of Clang plugins. This plugin creates an `ASTConsumer` that dumps all the function names contained in a translation unit. Still, the `ASTConsumer` does not require any modification to the AST; it just "consumes" the AST.

If you have some experience writing plugins for Clang, you might raise questions about the idea that `ASTConsumer` cannot modify the AST. Actually, Clang does not prevent you from modifying the AST from the `ASTConsumer`s; Clang even exposes a huge amount of public interfaces for creating, manipulating and deleting nodes in the AST. The problem is, the modifications you make to the AST is not guaranteed to be visible to other `ASTConsumer`s in the pipeline, which is crucial if you are working on a plugin that does some transformations on the code and wishes the code generator can emit your patch to the AST. Under such circumstances, it is highly probable that your patch will not be emitted to the generated code.

To further illustrate the problem, let's take an example. Imagine that you want to write a Clang plugin to do the following tasks on the AST and you wish the code generator could somehow emit the modified AST into target code:

1. Find any functions whose name starts with `Foo`;
2. For each matched function (referred to as `func`) in step 1, creates a new function named `Wrapper` in the same lexical scope as the `func` function that just calls the `func` function.

After you finish coding the plugin, load the plugin into Clang and run, you might find out that although the plugin has succesfully modified the AST, the functions created by your plugin still does not be emitted into the target code. That's because the `CodeGenerator` consumer is invoked by the `ParseAST` function, and `ParseAST` function does not know anything about your function; it does not take an eye on the AST and wait for it to be modified. Actually, every `ASTConsumer` is invoked by the `ParseAST` function; and any modification made to the AST in `ASTConsumer`s cannot be known by the `ParseAST` function, hence other `ASTConsumer`s cannot actually see your modification.
